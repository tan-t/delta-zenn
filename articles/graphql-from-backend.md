---
title: "GraphQLの本質は好きなフィールドをクエリできるということではない"
emoji: "📈"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["graphql"]
published: false
---

# 言いたいこと
- GraphQLはフロントエンドのためのAPIだと思われがち
- 「好きなフィールドをクエリできるんでしょ？」「永続層を露出させる」と思われがち
- リレーションをサーバーサイドで透過的かつ局所的に表現できるため、サーバーサイドもその構造の恩恵を受ける
- それにはリゾルバーという仕組みが重要
- ただN+1問題を構造的に引き起こしやすいためパフォーマンスには注意が必要

# お前は誰だ
- 前職ワークスアプリケーションズで4年、エンタープライズ・サーバーサイド畑
- 現職はSevenRich Accountingという会計事務所でソフトウェア開発を通じたスタートアップ支援をしている

=> エンプレからtoCまで触れてはきた

# 基本のおさらい
## GraphQLとは
- GraphQLとは、QLという名称から誤解されやすいが永続層との通信に使われるクエリ言語セットではなくweb APIに利用されるインターフェース言語とその周辺のツールセットである。
- Graphという名の通り、大きくは`Type`というノードと`Field`というエッジから構成されるグラフをクライアントがリクエストし、それを解決（resolve）した結果のグラフをサーバーが返却する。
- 電車で例えると、駅がノードで、線路がエッジとなる。
- 重要なのは、`Type`は`Field`を内包するのでは**ない**という点である。渋谷駅は山手線を持つわけではないし、ましてや新宿駅を所有しているわけでもないように。

![GraphQLとは](https://storage.googleapis.com/zenn-user-upload/l3a4aldbiuemigcwmtqixfijai10)

- GraphQLは、スキーマとリゾルバーから成る。

## スキーマ

- GraphQLはスキーマを持つ。これは`Type`がどのような`Field`を持つかというグラフの構造を表現する型である。
- 例えば、以下の通り。
```graphql
type User {
  id: String!
  followers: [User!]!
}
```
- この例は、「`User`」という`Type`が、`id`という文字列型の`Field`と、`followers`という`User`の配列型の`Field`を持つということを表現している。
- あくまでこれは「型の定義」をしているにすぎず、これがどのように解決されるかという実装はここにはない。

## リゾルバー
- GraphQLにおいて、クエリされたグラフの解決を行うサーバー側の実装はリゾルバーと呼ばれる。
- リゾルバーは`Type.Field` の関係性それぞれに対して、解決を行う関数のようなもの。

### シンプルパターン
- 以下のようなスキーマを考えてみる。
```graphql
type Query {
  listAllUser:[User!]!
}
```
- このようなスキーマがあった時に、クライアントが以下のようにクエリを実行したとする。
```graphql
query{
  listAllUser{
    id
  }
}
```
このとき、リゾルバーがやることは以下の通りである。

**(1) 「Query」タイプの「listAllUser」フィールドを解決する。例えば、何らかの永続層にユーザーデータがあるとしたらそこから一覧データを取得する。**

**(2) (1)で取得した「User」ノード一つ一つに対して、今度は「User」タイプの「id」フィールドを解決する。**

- 疑似的にコードを書くと以下のような実装になる。
```js
// (1) QueryタイプのlistAllUserを解決する
const queryListAllUserResolver = (source: Query) => {
  return Database.listAllUsers();
}

// (2) Userタイプのidを解決する
const userIdResolver = (source:User) => {
  return source.id
}
```

![簡単なクエリ](https://storage.googleapis.com/zenn-user-upload/srcl0a3yke31s141embfaejzjzrz)

- ちなみに、`Query.listAllUser`は配列を返しているのに、`User.id`は単数の`User`の処理をしているのに違和感を持たれる方も多いかもしれない。  
- 配列で返ってきた`Type`に対してはそれぞれに対してリゾルバーが適用される。これは一般的なGraphQLサーバーの仕様である。

※ このとき、「User」の「id」を解決するというだけのために関数を実装するのは手間なので、一般的にはタイプで解決されたオブジェクトが同名のフィールドを持っていれば自動で解決するような仕組みになっている。

### リレーション表現パターン

- さて、次は以下のようなクエリを考えてみる。
```graphql
query{
  listAllUser{
    id
    followers {
      id
    }
  }
}
```

- 取得したUserそれぞれに対して、followersを取得したい。

このとき、リゾルバーが追加でやることは以下の通りである。

**(3) (1)で取得した「User」ノード一つ一つに対して、今度は「User」タイプの「followers」フィールドを解決する。永続層にフォロー関係が保存されているとしたらそこから親である「User」ノードの情報をもとにしてフォロワーを取得する。**

- 疑似的にコードを書くと以下の通りになる。


```js
// (3) ユーザーからフォロワーを解決する
const userFollowersResolver = (source:User) => {
  const relations = Database.listFollowers({followed: source.id})
  const followers = Database.batchGetUsers({ids: relations.map(f=>f.followerId)});
  return followers
}
```

- このとき、リゾルバーは「User」タイプから「followers」フィールドの解決のみを行っている。

![リレーションの解決](https://storage.googleapis.com/zenn-user-upload/w337tdrbesq4toy8ssth7p80ggb3)

### リゾルバーの再利用

最後に、以下のようなクエリが発生した場合を考えてみる。

```graphql
type Query {
  listAllUsers:[User!]!
  getUser(id: String!):User
}
```

- `getUser`という、今度はリストでの取得ではなく単一のUserの取得を行いたい、となったとする。
- こうなった場合、「`getUser`」というフィールドを解決するリゾルバーを新たに実装する必要はもちろんあるが、`getUser`も`listAllUsers`も、どちらも「`User`」タイプを返却する、ということには違いはない。
- なので、`User`タイプの各フィールド（「`id`」、「`followers`」）をどのように取得するか、ということについては、以前実装したリゾルバーを再利用できる。


![リゾルバーの再利用](https://storage.googleapis.com/zenn-user-upload/z34l63we7qqj1vy1fl7cre1lajs7)
### リゾルバーの責任範囲

整理してみよう。

- `Type`は`Field`を**所有しない**。ただ、`Type`というノードと、`Field`というエッジの集合体たる**グラフ**をやり取りするのがGraphQL。
- リゾルバーという関数が、`Type`からの`Field`の**解決**を行う。リゾルバーとは、親となる`Type`を引数に取って、`Field`で指定した子の`Type`を返す関数といってもよい（実際には認証情報などの引数も取る。）
- リゾルバーは、同じ`Type`からの`Field`の解決であれば、**その`Type`がどのような経路で来たものなのかには関係なく、常に同じように**解決する。
- リゾルバーの責任範囲は、`Type`から`Field`を**解決する**というものに留まる。

# GraphQLの本質とメリットデメリット（サーバーサイド視点）

- 上記の性質は、実は[GraphQLのドキュメント](https://graphql.org/learn/)にはなかなか書いていない。
- 普通に"edge" "node"で検索しても何もヒットしない。
- リゾルバーを自分で実装して初めてその性質がわかることになるが、日本語で流布している情報はフロントエンド目線でのものが多いので辿り着きづらいと感じている。（個人の感想）
- また、サーバーサイドとクライアントサイドがそれぞれ何を実装するのかが分かりづらく、そもそもリゾルバーという概念に辿り着くのが難しい。（個人の感想）

## GraphQLの本質はリレーションをサーバーサイドで透過的かつ局所的に表現できること

- 究極的には、RESTとGraphQLの表現力は同じだと思われる。
- ただ、GraphQLが便利なのはリゾルバーという透過的な関数をサーバーサイドが持っているという点だと思う。

### 局所的

- 例えば、RESTサーバーサイドで `users/:id` というリソースを取得した時にそれを待ち受けるコントローラーを考える。

```js
const getUser = (id:string) => {
  const user = Database.getUser(id);
  const relations = Database.listFollowers({followed: source.id})
  const followers = Database.batchGetUsers({ids: relations.map(f=>f.followerId)});
  return {
    ...user,
    followers 
  }
}
```

- 適当に書けば上記のような関数になるだろう。
- ここで問題となるのは、「`getUser`」という関数が、followerをどのように解決するかということまで関心を持ちうるということだ。
- GraphQLのリゾルバーを実装したのなら、`Query.getUser`のリゾルバーは`User`タイプをどのように取得するかまでを関心とし、followerをどう解決するかは`User.followers`のリゾルバーの関心になる。これは設計がいけているいけていないという次元の話ではなく、強制的にそうなるようにしてくれる。

![リゾルバーの局所性](https://storage.googleapis.com/zenn-user-upload/hy02hvdicucm2ycpiopko4ca5gnn)

- リゾルバーを実装するサーバーサイドのエンジニアは、フロントエンドの要請やAPIのことを考えずに、個別のリレーションを表現することに集中すればよいということになる。

### 透過的

- クライアントから見ると、ある`Type`の`Field`がどのように解決されているかは隠蔽されている。
- リゾルバー自体は関数だが、常に同じ`Type`の同じ`Field`は同様に解決されるという意味で、リゾルバーは透過的な関数である（当然永続層その他のコンテクスト影響は受けるので純粋な参照透過関数では全くない。）
- 例えば、`User`というタイプの`followers`ひとつとっても、これが永続層で例えばドキュメント指向DBの`User`ドキュメントのフィールドとして直接格納されているのか、はたまた別のテーブルから取得処理をかけているのかを意識する必要が無い。
- インターフェースというのはそういうものといえばそこまでだが、GraphQLは関連するデータを一つのグラフで表現するため、よりその傾向が顕著となっている。

### サーバーサイドで

- リレーションの記述をクライアントサイドでやるのはしんどいというのは理解いただけるところと思う。

## リゾルバーの構造的な弱点

#### N+1問題によりパフォーマンス劣化を引き起こしやすい点
- リゾルバーは局所的な存在なので、グラフ全体がどういう状態であるかを基本的に関知しない。
- 例えばさっきの`User.followers`は、`User`が多数いたらその数だけ個別に永続層に問い合わせを行うことになるので全体でまとめて取得するよりネットワークその他のオーバーヘッドが大きくなる。

=> 大量データをUI上扱わないユースケースに便利


#### 透過的であるがゆえにパフォーマンスボトルネックすらも隠蔽され、まずいクエリを防ぎづらい点
- クライアント側はその`Field`のリゾルバーが永続層への問い合わせを発生させるかどうかを意識できない。
- なので知らず知らずのうちに負荷の高いリクエストをできてしまう。

=> 監視が重要

# まとめ

- GraphQLはフロントエンドのためのAPIだと思われがち
- リレーションをサーバーサイドで透過的かつ局所的に表現できるため、サーバーサイドもその構造の恩恵を受ける
- ただN+1問題を構造的に引き起こしやすいためパフォーマンスには注意が必要

